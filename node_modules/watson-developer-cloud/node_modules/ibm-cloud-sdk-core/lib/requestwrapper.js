"use strict";
/**
 * Copyright 2014 IBM Corp. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = require("axios");
var extend = require("extend");
var FormData = require("form-data");
var https = require("https");
var querystring = require("querystring");
var helper_1 = require("./helper");
// tslint:disable-next-line:no-var-requires
var pkg = require('../package.json');
var isBrowser = typeof window === 'object';
var globalTransactionId = 'x-global-transaction-id';
// axios sets the default Content-Type for `post`, `put`, and `patch` operations
// to 'application/x-www-form-urlencoded'. This causes problems, so overriding the
// defaults here
['post', 'put', 'patch'].forEach(function (method) {
    axios_1.default.defaults.headers[method]['Content-Type'] = 'application/json';
});
/**
 * @private
 * @param {string} path
 * @param {Object} params
 * @returns {string}
 */
function parsePath(path, params) {
    if (!path || !params) {
        return path;
    }
    return Object.keys(params).reduce(function (parsedPath, param) {
        var value = encodeURIComponent(params[param]);
        return parsedPath.replace(new RegExp("{" + param + "}"), value);
    }, path);
}
/**
 * Determine if the error is due to bad credentials
 * @private
 * @param {Object} error - error object returned from axios
 * @returns {boolean} true if error is due to authentication
 */
function isAuthenticationError(error) {
    var isAuthErr = false;
    var code = error.status;
    var body = error.data;
    // handle specific error from iam service, should be relevant across platforms
    var isIamServiceError = body.context &&
        body.context.url &&
        body.context.url.indexOf('iam') > -1;
    if (code === 401 || code === 403 || isIamServiceError) {
        isAuthErr = true;
    }
    return isAuthErr;
}
/**
 * Return true if object has a specified property that is a string
 * @private
 * @param {Object} obj - object to look for property in
 * @param {string} property - name of the property to look for
 * @returns {boolean} true if property exists and is string
 */
function hasStringProperty(obj, property) {
    return Boolean(obj[property] && typeof obj[property] === 'string');
}
/**
 * Look for service error message in common places, by priority
 * first look in `errors[0].message`, then in `error`, then in
 * `message`, then in `errorMessage`
 * @private
 * @param {Object} response - error response body received from service
 * @returns {string | undefined} the error message if is was found, undefined otherwise
 */
function parseServiceErrorMessage(response) {
    var message;
    if (Array.isArray(response.errors) && response.errors.length > 0 && hasStringProperty(response.errors[0], 'message')) {
        message = response.errors[0].message;
    }
    else if (hasStringProperty(response, 'error')) {
        message = response.error;
    }
    else if (hasStringProperty(response, 'message')) {
        message = response.message;
    }
    else if (hasStringProperty(response, 'errorMessage')) {
        message = response.errorMessage;
    }
    return message;
}
/**
 * Format error returned by axios
 * @param  {Function} cb the request callback
 * @private
 * @returns {request.RequestCallback}
 */
function formatError(axiosError) {
    // return an actual error object,
    // but make it flexible so we can add properties like 'body'
    var error = new Error();
    // axios specific handling
    // this branch is for an error received from the service
    if (axiosError.response) {
        axiosError = axiosError.response;
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        delete axiosError.config;
        delete axiosError.request;
        error.name = axiosError.statusText;
        error.code = axiosError.status;
        error.message = parseServiceErrorMessage(axiosError.data) || axiosError.statusText;
        // some services bury the useful error message within 'data'
        // adding it to the error under the key 'body' as a string or object
        var errorBody = void 0;
        try {
            // try/catch to handle objects with circular references
            errorBody = JSON.stringify(axiosError.data);
        }
        catch (e) {
            // ignore the error, use the object, and tack on a warning
            errorBody = axiosError.data;
            errorBody.warning = 'body contains circular reference';
        }
        error.body = errorBody;
        // attach headers to error object
        error.headers = axiosError.headers;
        // print a more descriptive error message for auth issues
        if (isAuthenticationError(axiosError)) {
            error.message = 'Access is denied due to invalid credentials.';
        }
    }
    else if (axiosError.request) {
        // The request was made but no response was received
        // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
        // http.ClientRequest in node.js
        error.message = 'Response not received. Body of error is HTTP ClientRequest object';
        error.body = axiosError.request;
    }
    else {
        // Something happened in setting up the request that triggered an Error
        error.message = axiosError.message;
    }
    return error;
}
exports.formatError = formatError;
/**
 * Creates the request.
 * 1. Merge default options with user provided options
 * 2. Checks for missing parameters
 * 3. Encode path and query parameters
 * 4. Call the api
 * @private
 * @returns {ReadableStream|undefined}
 * @throws {Error}
 */
function sendRequest(parameters, _callback) {
    var options = extend(true, {}, parameters.defaultOptions, parameters.options);
    var path = options.path, body = options.body, form = options.form, formData = options.formData, qs = options.qs, method = options.method, rejectUnauthorized = options.rejectUnauthorized;
    var url = options.url, headers = options.headers;
    var multipartForm = new FormData();
    // Form params
    if (formData) {
        // Remove keys with undefined/null values
        // Remove empty objects
        // Remove non-valid inputs for buildRequestFileObject,
        // i.e things like {contentType: <contentType>}
        Object.keys(formData).forEach(function (key) {
            if (formData[key] == null ||
                helper_1.isEmptyObject(formData[key]) ||
                (formData[key].hasOwnProperty('contentType') && !formData[key].hasOwnProperty('data'))) {
                delete formData[key];
            }
        });
        // Convert file form parameters to request-style objects
        Object.keys(formData).forEach(function (key) {
            if (formData[key].data != null) {
                formData[key] = helper_1.buildRequestFileObject(formData[key]);
            }
        });
        // Stringify arrays
        Object.keys(formData).forEach(function (key) {
            if (Array.isArray(formData[key])) {
                formData[key] = formData[key].join(',');
            }
        });
        // Convert non-file form parameters to strings
        Object.keys(formData).forEach(function (key) {
            if (!helper_1.isFileParam(formData[key]) &&
                !Array.isArray(formData[key]) &&
                typeof formData[key] === 'object') {
                (formData[key] = JSON.stringify(formData[key]));
            }
        });
        // build multipart form data
        Object.keys(formData).forEach(function (key) {
            // handle files differently to maintain options
            if (formData[key].value) {
                multipartForm.append(key, formData[key].value, formData[key].options);
            }
            else {
                multipartForm.append(key, formData[key]);
            }
        });
    }
    // Path params
    url = parsePath(url, path);
    // Headers
    options.headers = extend({}, options.headers);
    // Convert array-valued query params to strings
    if (qs && Object.keys(qs).length > 0) {
        Object.keys(qs).forEach(function (key) { return Array.isArray(qs[key]) && (qs[key] = qs[key].join(',')); });
    }
    // Add service default endpoint if options.url start with /
    if (url && url.charAt(0) === '/') {
        url = parameters.defaultOptions.url + url;
    }
    var data = body;
    if (form) {
        data = querystring.stringify(form);
        headers['Content-type'] = 'application/x-www-form-urlencoded';
    }
    if (formData) {
        data = multipartForm;
        // form-data generates headers that MUST be included or the request will fail
        headers = extend(true, {}, headers, multipartForm.getHeaders());
    }
    // accept gzip encoded responses if Accept-Encoding is not already set
    headers['Accept-Encoding'] = headers['Accept-Encoding'] || 'gzip';
    var requestParams = {
        url: url,
        method: method,
        headers: headers,
        params: qs,
        data: data,
        responseType: options.responseType || 'json',
        paramsSerializer: function (params) {
            return querystring.stringify(params);
        },
        // a custom httpsAgent is needed to support ICP
        httpsAgent: new https.Agent({ rejectUnauthorized: rejectUnauthorized }),
    };
    axios_1.default(requestParams)
        .then(function (res) {
        // the other sdks use the interface `result` for the body
        _callback(null, res.data, res);
    })
        .catch(function (error) {
        _callback(formatError(error));
    });
}
exports.sendRequest = sendRequest;
//# sourceMappingURL=requestwrapper.js.map